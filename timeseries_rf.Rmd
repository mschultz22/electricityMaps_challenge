---
title: "timeseries_forecast"
output: html_document
date: '2022-07-22'
---
# acknoledgements lol 
[https://www.statworx.com/en/content-hub/blog/time-series-forecasting-with-random-forest]

```{r}
# load the packages
suppressPackageStartupMessages(require(tidyverse))
suppressPackageStartupMessages(require(tsibble))
suppressPackageStartupMessages(require(randomForest))
suppressPackageStartupMessages(require(forecast))

# specify the csv file (your path here)
file <- ".../DK-DK2.csv"

# read in the csv file
denmark_tbl <- readr::read_delim(
  file = file
  #delim = ";",
  #col_names = c("Year", "Type", month.abb),
  #skip = 1,
  #col_types = "iciiiiiiiiiiii",
  #na = c("...")
  ) %>% 
  select(-c(timeobj, zone_something)) %>% 
  #gather(Date, Value, -Year) %>% 
  #unite("Date", c(Date, Year), sep = " ") %>% 
  #mutate(
  #   Date = Date %>% 
  #     lubridate::parse_date_time("m y") %>% 
  #     yearmonth()
  # ) %>% 
  drop_na() %>% 
  
  # should set index to datetime I think
  as_tsibble(index = "datetime") 

# convert to ts format
denmark_ts <- as.ts(denmark_tbl)
```
 
# Check for missings
```{r}
# implicit missings
has_gaps(denmark_tbl)

# explicit missings
colSums(is.na(denmark_tbl[, "carbon_intensity_avg"]))
```

# visualize
```{r}
plot_org <- denmark_tbl %>% 
  ggplot(aes(datetime, carbon_intensity_avg / 1000)) + # to get the axis on a more manageable scale
  geom_line() +
  theme_minimal() +
  labs(title = "Carbon Intensity 2014 - 2019", x = "Year", y = "Intensity")
```


# Differencing
```{r}
# pretend we're in December 2017 and have to forecast the next twelve months

# this might look like a random timestamp?
denmark_ts_org <- window(denmark_ts, end = c(2017, 12))

# estimate the required order of differencing
n_diffs <- nsdiffs(denmark_ts_org)

# log transform and difference the data
denmark_ts_trf <- denmark_ts_org %>% 
  log() %>% 
  diff(n_diffs)

# check out the difference! (pun)
plot_trf <- denmark_ts_trf %>% 
  autoplot() +
  xlab("Year") +
  ylab("Intensity") +
  ggtitle("Carbon Intensity 2014 - 2019") +
  theme_minimal()

gridExtra::grid.arrange(plot_org, plot_trf)
```

# Time Delay Embedding
```{r}
lag_order <- 48  # the desired number of lags (48 hours)
horizon <- 24 # the forecast horizon (24 hours)

denmark_ts_mbd <- embed(denmark_ts_trf, lag_order + 1) # embedding magic!
```

# Modeling

```{r}
y_train <- denmark_ts_mbd[, 1] # the target
# y_train <- denmark_ts_mbd[, carbon_intensity_avg] # the target
X_train <- denmark_ts_mbd[, -1] # everything but the target

# maybe set a random timestamp
y_test <- window(tax_ts, start = c(2018, 1), end = c(2018, 12)) # the year 2018
X_test <- denmark_ts_mbd[nrow(denmark_ts_mbd), c(1:lag_order)] # the test set consisting
# of the six most recent values (we have six lags) of the training set. It's the
# same for all models.
```


# Forecasting
```{r}
forecasts_rf <- numeric(horizon)

for (i in 1:horizon){
  # set seed
  set.seed(42)

  # fit the model
  fit_rf <- randomForest(X_train, y_train)

  # predict using the test set
  forecasts_rf[i] <- predict(fit_rf, X_test)

  # here is where we repeatedly reshape the training data to reflect the time distance
  # corresponding to the current forecast horizon.
  y_train <- y_train[-1] 

  X_train <- X_train[-nrow(X_train), ] 
}
```


# Back to original scale
```{r}
# calculate the exp term
exp_term <- exp(cumsum(forecasts_rf))

# extract the last observation from the time series (y_t)
last_observation <- as.vector(tail(denmark_ts_org, 1))

# calculate the final predictions
backtransformed_forecasts <- last_observation * exp_term

# convert to ts format
y_pred <- ts(
  backtransformed_forecasts,
  start = c(2018, 1),
  frequency = 12
)

# add the forecasts to the original tibble
denmark_tbl <- denmark_tbl %>% 
  mutate(Forecast = c(rep(NA, length(denmark_ts_org)), y_pred))

# visualize the forecasts
plot_fc <- denmark_tbl %>% 
  ggplot(aes(x = datetime)) +
  geom_line(aes(y = carbon_intensity_avg / 1000)) +
  geom_line(aes(y = Forecast / 1000), color = "blue") +
  theme_minimal() +
  labs(
    title = "Forecast of Carbon Intensity for XXX",
    x = "Year",
    y = "Intensity"
  )

accuracy(y_pred, y_test)
```

# Better than simple model?
```{r}
benchmark <- forecast(snaive(denmark_ts_org), h = horizon)

denmark_ts %>% 
  autoplot() +
  autolayer(benchmark, PI = FALSE)

accuracy(benchmark, y_test)
```

